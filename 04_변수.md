# 04. 변수

## 4.1. 변수란 무엇인가? 왜 필요한가?

```javascript
10 + 20;
```

- 자바스크립트 엔진은 위 **자바스크립트 코드를 계산(evaluation)** 하려면 `10`, `20`, `+`라는 기호(literal과 operator)의 의미를 알고 있어야 하며, `10 + 20`이라는 식(expression)의 의미도 해석(parsing)할 수 있어야 함
- `10 + 20`이라는 식의 의미를 해석하면 `+` 연산을 수행하기 위해 `+` 연산자의 좌변과 우변의 숫자 값, 즉 **피연산자(operand)를 기억**해야 함
- `10`과 `20`은 메모리 상의 임의의 위치(메모리 주소)에 기억(저장)되고, CPU는 이 값을 읽어들여 연산을 수행
- 연산 결과로 생성된 `30`도 메모리 상의 임의의 위치에 저장됨

<br>

- CPU가 연산해서 만들어낸 숫자 값 30을 **재사용**할 수 없는 문제 발생
- 메모리 주소를 통해 저장된 메모리 공간에 직접 접근하는 방법이 있지만, 치명적 오류를 발생시킬 가능성 매우 높음

<br>

- **변수(variable)**

  - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
  - 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘
  - **값의 위치를 가리키는 상징적인 이름**

- 변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행됨
- 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요X, 안전하게 값에 접근 가능

<br>

> **변수에 여러 개의 값을 저장하는 방법**

```javascript
// 변수는 하나의 값을 저장하기 위한 수단
var userId = 1;
var userName = "Lee";

// 객체나 배열 같은 자료구조를 사용하면 여러 개의 값을 하나로 그룹화해서 하나의 값처럼 사용 가능
var user = { id: 1, name: "Lee" };

var users = [
  { id: 1, name: "Lee" },
  { id: 2, name: "Kim" },
];
```

<br>

```javascript
var result = 10 + 20;
```

- **변수**: 메모리 공간에 저장된 값 30을 다시 읽어 들여 재사용할 수 있도록 값이 저장된 메모리 공간에 상징적인 이름을 붙인 것
- **변수 이름(변수명)**: 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- **변수 값**: 변수에 저장된 값
- **할당(대입, 저장)**: 변수에 값을 저장하는 것
- **참조(reference)**: 변수에 저장된 값을 읽어 들이는 것
- 변수 이름을 사용해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환

<br><br>

## 4.2. 식별자(identifier)

- **어떤 값을 구별해서 식별할 수 있는 고유한 이름**
- 메모리 공간에 저장되어 있는 값을 구별해서 식별해 내기 위해 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 함
- 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 함
- **값이 아니라 메모리 주소를 기억**
- 메모리 주소에 붙인 이름
- 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름

<br><br>

## 4.3. 변수 선언(variable declaration)

- 변수를 생성하는 것
- 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 것
- 변수 선언에 의해 확보된 메모리 공간은 확보가 해제(release)되기 전까지 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용 가능
- **변수 사용시 반드시 선언 필요**
- **변수 선언할 때 `var`, `let`, `const` 키워드 사용**

<br>

```javascript
var score; // 변수 선언(변수 선언문)
```

- `var` 키워드는 뒤에 오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 키워드
- **키워드**

  - 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어
  - 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행

- 위 변수 선언문은 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보함
- 메모리 공간은 비어 있을 것으로 생각할 수 있으나 확보된 메모리 공간에는 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 초기화됨

<br>

- 자바스크립트 엔진의 변수 선언 2단계
  - **선언 단계**: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재 알림
  - **초기화 단게**: 값을 지정하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화
- 초기화(initialization): 변수가 선언된 이후 최초로 값을 할당하는 것
- 메모리 공간을 확보한 다음, 값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값 나올 수 있음
  - 쓰레기 값(garbage value): 확보된 메모리 공간에 이전에 다른 애플리케이션이 사용했던 값이 남아 있는 경우

<br>

- 선언하지 않은 식별자에 접근하면 `ReferenceError`(참조 에러) 발생
- `ReferenceError`: 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생한는 에러

<br><br>

## 4.4. 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score); // undefined

var score; // 변수 선언문
```

- 변수 선언문보다 변수를 참조하는 코드가 앞에 위치
- 자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행되므로 참조 에러(`ReferenceError`)가 발생할 것처럼 보이지만 `undefined` 출력
- **변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임(runtime)이 아니라 그 이전 단계에서 먼저 실행되기 때문**
- 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행
- 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수 참조 가능
- **변수 호이스팅(varialbe hoisting)**: 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 변수 뿐만 아니라 모든 선언문은 런타임 이전 단계에서 먼저 실행됨

<br><br>

## 4.5. 값의 할당(assignment)

- 변수에 값을 할당(대입, 저장)할 때 할당 연산자 `=` 사용
- 할당 연산자는 우변의 값을 좌변의 변수에 할당

```javascript
var score; // 변수 선언
score = 80; // 값의 할당

// 하나의 문(statement)으로 단축 표현 가능
var score = 80; // 변수 선언과 값의 할당
```

- 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행
- **변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행됨**

```javascript
console.log(score); // undefined

var score; // 변수 선언
score = 80; // 값의 할당

console.log(score); // 80
```

- `score = 80;` 시점에 이미 변수 선언이 완료된 상태이고, 이미 `undefined`로 초기화되어 있음
- `score` 변수에 값을 할당하면 `score` 변수의 값은 `undefined`에서 새롭게 할당된 숫자 값 80으로 변경(재할당)됨

```javascript
console.log(score); // undefined

var score = 80; // 변수 선언과 값의 할당

console.log(score); // 80
```

- 변수에 값을 할당할 때는 이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 곳에 할당 값 80을 저장

<br><br>

## 4.6. 값의 재할당

- **재할당**: 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것

```javascript
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

- `var` 키워드로 선언한 변수는 값 재할당 가능

<br>

- **값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(constant)**
- 상수는 단 한 번만 할당할 수 있는 변수

<br>

- 변수에 값을 재할당하면 `score` 변수의 값은 이전 값 80에서 재할당한 값 90으로 변경됨
- 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 90을 저장
- `score` 이전 값인 `undefined`와 80은 어떤 식별자와도 연결되어 있지 않음
- 불필요한 값들은 가비지 콜렉터에 의해 자동 해제됨(해제 시점 예측 불가)

> **가비지 콜렉터**
>
> - 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제(release)하는 기능
> - 더 이상 사용되지 않는 메모리: 어떤 식별자도 참조하지 않는 메모리 공간

<br><br>

## 4.7. 식별자 네이밍 규칙

- 식별자가 준수해야 할 네이밍 규칙
  - **식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(`_`), 달러 기호(`$`) 포함 가능**
  - **단, 식별자는 특수문자를 제외한 문자, 언더스코어(`_`), 달러 기호(`$`)로 시작해야 함. 숫자로 시작 허용X**
  - **예약어는 식별자로 사용 불가**

<br>

- 변수 이름으로 사용 가능한 식별자

  ```javascript
  var person, $elem, _name, first_name, vall;
  ```

- ES5부터 식별자를 만들 때 유니코드 문자를 허용하므로 알파벳 외의 한글이나 일본어 식별자 사용 가능

  ```javascript
  var 이름;
  ```

- 명명 규칙에 위배되는 식별자(사용 불가)

  ```javascript
  var first-name;  // SyntaxError: Unexpected token -
  var 1st;  // SyntaxError: Invalid or unexpected token
  var this;  // SyntaxError: Unexpected token this
  ```

- 자바스크립트는 대소문자를 구별하므로 다음 변수는 각각 별개의 변수

  ```javascript
  var firstname;
  var firstName;
  var FIRSTNAME;
  ```

- 변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 함

  ```javascript
  var x = 3; // NG. x 변수가 의미하는 바를 알 수 없음
  var score = 100; // OK. score 변수는 점수를 의미
  ```

- 변수 선언에 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못한 것

  ```javascript
  // 경과 시간. 단위는 날짜
  var d; // NG

  var elapsedTimeInDays; // OK
  ```

- 네이밍 컨벤션(naming convention): 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한 눈에 구분하기 위해 규정한 명명 규칙
- 자주 사용되는 네이밍 컨벤션 4가지 유형

  ```javascript
  // 카멜 케이스(camelCase)
  var firstName;

  // 스네이크 케이스(snake_case)
  var first_name;

  // 파스칼 케이스(ParscalCase)
  var FirstName;

  // 헝가리안 케이스(typeHungarianCase)
  var strFirstName; // type + identifier
  var $elem = document.getElementById("myId"); // DOM 노트
  var observable$ = fromEvent(document, "click"); // RxJS 옵저버블
  ```

- 일반적으로 변수나 함수의 이름에 카멜 케이스 사용
- 생성자 함수, 클래스의 이름에 파스칼 케이스 사용
- 코드 전체의 가독성을 높이려면 카멜 케이스와 파스칼 케이스 따르는 것이 유리
